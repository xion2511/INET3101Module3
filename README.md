# INET3101Module3

Problem Statement - Colossus Airlines operates one airplane with twenty-four seats and runs two flights each day—an Outbound flight and an Inbound flight. The task is to write a C program that maintains reservations for these flights using an array of structures in which each seat record stores a seat ID, an “assigned” flag, a first name, and a last name. The program first displays a main menu that allows the user to choose the Outbound flight, the Inbound flight, or to quit. After selecting a flight, the program shows a second menu that performs operations for that flight only: it can report the number of empty seats, list the seat numbers that are empty, display an alphabetical list of assigned seats by last then first name, assign a customer to a specific seat, delete an existing seat assignment with confirmation, or return to the main menu. After each operation, the second menu reappears until the user chooses to return, and choosing Quit ends the program.

Describe the Solution - This solution follows the chapters listed in the required reading by relying on fundamental data types, formatted I/O with printf and scanf, selection and looping statements, character I/O with basic validation, functions, arrays, and structures. Two Flight objects are created—one for the Outbound flight and one for the Inbound flight—and each flight contains an array of twenty-four Seat structures. Initialization sets every seat to empty with IDs from 1 to 24. The main function presents the first-level menu and routes the user to a second-level menu that operates on the chosen flight. Counting empty seats is implemented by scanning the seat array and tallying entries whose “assigned” flag is zero. Listing empty seats prints the corresponding seat IDs in a single pass. The alphabetical listing is produced by building a small index array of assigned seats and performing a beginner-friendly selection sort on that index based on last name and then first name; this approach keeps the physical seat order intact and avoids advanced library calls. Assigning a seat prompts for a seat number (with 0 used as a simple cancel option) and then reads a one-word first and last name, validating that the seat is within range and unassigned before writing to the record. Deleting an assignment prompts for a seat number (again allowing cancel with 0) and asks for a y/n confirmation before clearing the record. Input handling uses scanf together with a small helper that clears the remainder of the input line to keep the scanner in sync. The program is compiled and run with standard tools—for example, gcc -std=c11 -Wall -Wextra -O2 solution_simple.c -o colossus followed by ./colossus—and requires no additional libraries or files.

Pros and Cons of the Solution - I think the primary strength of this solution is that it stays squarely within the introductory material: it uses arrays and structures, simple loops and conditionals, and straightforward formatted input and output. The code is also divided into short, focused functions, which makes the control flow easy to follow and the program simple to grade or extend. The selection-sort approach for the alphabetical list is easy to explain and perfectly adequate for a fixed set of twenty-four seats. On the other hand, the program intentionally avoids persistence, so reservations are not saved once the program exits; it limits names to single words with a fixed maximum length; and its O(n²) sorting method would not scale to much larger datasets, even though it is fine here. The use of scanf keeps the code approachable for beginners, but it is less robust than full line-buffered parsing.
